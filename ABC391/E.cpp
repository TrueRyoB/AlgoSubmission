#include <bits/stdc++.h>
#include <atcoder/all>
using namespace std;
using namespace atcoder;
#define int long long

int32_t main() {
    //戻って試してを階層分繰り返さないといけないからか...
    //最大階層はN<=13である
    //dfsっぽい
    //0) 階層分の木を作る
    //1) 少数派が0か1かどちらかを把握する
    //2) 各階層において、"少数派の一つの改宗"における最小値を取らせる
    //3) 足すなり焼くなりする
    //4) dfs + 分割統治っぽい
    int N; cin>>N; int len = pow(N, 3);
    vector<int> v(len); for(auto& e:v) cin>>e;

    //比較対象の集め方をわかっていない...
    //演算結果は呼び出してが勝手にreturnで持ってくるので
    //子分の座標を把握しないといけない...!
    //子分が最低値の時、なんか計算させる？？

    //1) 子分の数値(1か0)を得る
    //2) 子分に変更処理の数値を求めさせる
    //3) 返す
    //子分がいない場合→隣接と比較する...? 視点は毎回 (i+1)にして隣接を見させる
    //処理毎に2個しかみなくて良いため、負荷はO(2^N)

    //12:06までには仕事に戻らないとまずいので、なんとかする

    // auto dqdfs = [&](auto dqdfs, int )
    //落ちます

    return 0;
}